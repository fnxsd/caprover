"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const child_process_1 = require("child_process");
const command_exists_1 = require("command-exists");
const StdOutUtil_1 = require("./StdOutUtil");
const StorageHelper_1 = require("./StorageHelper");
const Constants_1 = require("./Constants");
const Utils_1 = require("./Utils");
const isWindows = process.platform === 'win32';
function validateIsGitRepository() {
    if (!fs.pathExistsSync('./.git')) {
        StdOutUtil_1.default.printError('You are not in a git root directory: this command will only deploy the current directory.\n' +
            'Run "caprover deploy --help" to know more deployment options... (e.g. tar file or image name)\n', true);
    }
    if (!command_exists_1.sync('git')) {
        StdOutUtil_1.default.printError('"git" command not found: CapRover needs "git" to create tar file from your branch source files.\n' +
            'Run "caprover deploy --help" to know more deployment options... (e.g. tar file or image name)\n', true);
    }
}
exports.validateIsGitRepository = validateIsGitRepository;
function validateDefinitionFile() {
    if (!fs.pathExistsSync('./captain-definition')) {
        if (fs.pathExistsSync('./Dockerfile')) {
            StdOutUtil_1.default.printWarning('**** Warning ****');
            StdOutUtil_1.default.printMessage('No captain-definition was found in main directory: falling back to Dockerfile.\n');
        }
        else {
            StdOutUtil_1.default.printWarning('**** Warning ****');
            StdOutUtil_1.default.printMessage('No captain-definition was found in main directory: unless you have specified a special path for your captain-definition, this build will fail!\n');
        }
    }
    else {
        let content = null;
        try {
            content = JSON.parse(fs.readFileSync('./captain-definition', 'utf8'));
        }
        catch (e) {
            StdOutUtil_1.default.printError(`captain-definition file is not a valid JSON!\n${e.message ||
                e}\n`, true);
        }
        if (!content || !content.schemaVersion) {
            StdOutUtil_1.default.printError('captain-definition needs "schemaVersion": please see docs!\n', true);
        }
    }
}
exports.validateDefinitionFile = validateDefinitionFile;
function isNameValid(value) {
    return !!(value && value.match(/^[-\d\w]+$/i) && !value.includes('--'));
}
exports.isNameValid = isNameValid;
function getErrorForIP(value) {
    value = value.trim();
    if (value === Constants_1.default.SAMPLE_IP) {
        return 'Enter a valid IP.';
    }
    if (!Utils_1.default.isIpAddress(value)) {
        return `This is an invalid IP: ${value}.`;
    }
    return true;
}
exports.getErrorForIP = getErrorForIP;
function getErrorForDomain(value, skipAlreadyStored) {
    if (value === Constants_1.default.SAMPLE_DOMAIN) {
        return 'Enter a valid URL.';
    }
    const cleaned = Utils_1.default.cleanAdminDomainUrl(value);
    if (!cleaned) {
        return `This is an invalid URL: ${StdOutUtil_1.default.getColoredMachineUrl(value)}.`;
    }
    if (!skipAlreadyStored) {
        const found = StorageHelper_1.default.get()
            .getMachines()
            .find(machine => Utils_1.default.cleanAdminDomainUrl(machine.baseUrl) === cleaned);
        if (found) {
            return `${StdOutUtil_1.default.getColoredMachineUrl(cleaned)} already exist as ${StdOutUtil_1.default.getColoredMachineName(found.name)} in your currently logged in machines. If you want to replace the existing entry, you have to first use <logout> command, and then re-login.`;
        }
    }
    return true;
}
exports.getErrorForDomain = getErrorForDomain;
function getErrorForPassword(value, constraint) {
    if (!value || !value.trim()) {
        return 'Please enter password.';
    }
    if (typeof constraint === 'number' && value.length < constraint) {
        return `Password is too short, min ${constraint} characters.`;
    }
    if (typeof constraint === 'string' && value !== constraint) {
        return `Passwords do not match.`;
    }
    return true;
}
exports.getErrorForPassword = getErrorForPassword;
function getErrorForMachineName(value, checkExisting) {
    value = value.trim();
    const exist = StorageHelper_1.default.get().findMachine(value) ? true : false;
    if (exist && !checkExisting) {
        return `${StdOutUtil_1.default.getColoredMachineName(value)} already exist. If you want to replace the existing entry, you have to first use <logout> command, and then re-login.`;
    }
    if (checkExisting && !exist) {
        return `${StdOutUtil_1.default.getColoredMachineName(value)} CapRover machine not exist.`;
    }
    if (checkExisting || isNameValid(value)) {
        return true;
    }
    return 'Please enter a valid CapRover machine name: small letters, numbers, single hyphen.';
}
exports.getErrorForMachineName = getErrorForMachineName;
function getErrorForAppName(apps, value) {
    value = value.trim();
    const app = apps.find(a => a.appName === value);
    if (!app) {
        return `${StdOutUtil_1.default.getColoredAppName(value)} app not exist on this CapRover machine.`;
    }
    if (app.isAppBuilding) {
        return `${StdOutUtil_1.default.getColoredAppName(value)} app is currently in a building process.`;
    }
    return true;
}
exports.getErrorForAppName = getErrorForAppName;
function getErrorForBranchName(value) {
    if (!value || !value.trim()) {
        return 'Please enter branch name.';
    }
    value = value.trim();
    try {
        const cmd = isWindows
            ? child_process_1.execSync(`git rev-parse ${value} > NUL`)
            : child_process_1.execSync(`git rev-parse ${value} 2>/dev/null`);
        if (cmd) {
            return true;
        }
    }
    catch (e) {
        // Do nothing
    }
    return `Cannot find hash of last commit on branch "${value}".`;
}
exports.getErrorForBranchName = getErrorForBranchName;
function getErrorForEmail(value) {
    if (!value || !value.trim()) {
        return 'Please enter email.';
    }
    if (!Utils_1.default.isValidEmail(value)) {
        return 'Please enter a valid email.';
    }
    return true;
}
exports.getErrorForEmail = getErrorForEmail;
function userCancelOperation(cancel, c) {
    if (cancel) {
        StdOutUtil_1.default.printMessage((c ? '\n' : '') +
            '\nOperation cancelled by the user!' +
            (!c ? '\n' : ''), true);
    }
    return false;
}
exports.userCancelOperation = userCancelOperation;
//# sourceMappingURL=ValidationsHandler.js.map