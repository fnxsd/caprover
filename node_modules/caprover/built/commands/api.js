#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const Constants_1 = require("../utils/Constants");
const Utils_1 = require("../utils/Utils");
const StdOutUtil_1 = require("../utils/StdOutUtil");
const CliHelper_1 = require("../utils/CliHelper");
const CliApiManager_1 = require("../api/CliApiManager");
const ValidationsHandler_1 = require("../utils/ValidationsHandler");
const Command_1 = require("./Command");
const K = Utils_1.default.extendCommonKeys({
    path: 'path',
    method: 'method',
    data: 'data',
    out: 'output'
});
class Api extends Command_1.default {
    constructor() {
        super(...arguments);
        this.command = 'api';
        this.usage = '[options]\n' +
            '       api -c file\n' +
            '       api [-c file] [-n name] [-t path] [-m method] [-d dataJsonString]\n' +
            '       api [-c file] -u url [-p password] [-n name] [-t path] [-m method] [-d dataJsonString]\n' +
            '  Use --caproverName to use an already logged in CapRover machine\n' +
            '  Use --caproverUrl and --caproverPassword to login on the fly to a CapRover machine, if also --caproverName is present, login credetials are stored locally';
        this.description = 'Call a generic API on a specific CapRover machine. Use carefully only if you really know what you are doing!';
        this.machines = CliHelper_1.default.get().getMachinesAsOptions();
        this.options = (params) => [
            this.getDefaultConfigFileOption(),
            {
                name: K.url,
                char: 'u',
                env: 'CAPROVER_URL',
                type: 'input',
                message: `CapRover machine URL address, it is "[http[s]://][${Constants_1.default.ADMIN_DOMAIN}.]your-captain-root.domain"`,
                when: false,
                filter: (url) => Utils_1.default.cleanAdminDomainUrl(url) || url,
                validate: (url) => ValidationsHandler_1.getErrorForDomain(url, true)
            },
            {
                name: K.pwd,
                char: 'p',
                env: 'CAPROVER_PASSWORD',
                type: 'password',
                message: 'CapRover machine password',
                when: !!this.findParamValue(params, K.url),
                validate: (password) => ValidationsHandler_1.getErrorForPassword(password)
            },
            {
                name: K.name,
                char: 'n',
                env: 'CAPROVER_NAME',
                message: params
                    ? 'select the CapRover machine name you want to call API to'
                    : 'CapRover machine name, to load/store credentials',
                type: 'list',
                choices: this.machines,
                when: !this.findParamValue(params, K.url),
                filter: (name) => !this.findParamValue(params, K.name)
                    ? ValidationsHandler_1.userCancelOperation(!name, true) || name
                    : name.trim(),
                validate: !this.findParamValue(params, K.url)
                    ? (name) => ValidationsHandler_1.getErrorForMachineName(name, true)
                    : undefined
            },
            CliHelper_1.default.get().getEnsureAuthenticationOption('', () => this.paramValue(params, K.url), () => this.paramValue(params, K.pwd), () => this.paramValue(params, K.name), (machine) => __awaiter(this, void 0, void 0, function* () {
                this.machine = machine;
                try {
                    yield CliApiManager_1.default.get(machine).getCaptainInfo();
                }
                catch (e) {
                    StdOutUtil_1.default.printError(`\nSomething bad happened during calling API to ${StdOutUtil_1.default.getColoredMachineUrl(machine.baseUrl)}.\n${e.message || e}`, true);
                }
            })),
            {
                name: K.path,
                char: 't',
                env: 'CAPROVER_API_PATH',
                message: 'API path to call, starting with / (eg. "/user/system/info")',
                type: 'input',
                default: params && '/user/system/info',
                filter: (path) => path.trim(),
                validate: (path) => path && path.startsWith('/')
                    ? true
                    : 'Please enter a valid path.'
            },
            {
                name: K.method,
                char: 'm',
                env: 'CAPROVER_API_METHOD',
                message: params
                    ? 'select the API method you want to call'
                    : `API method to call, one of: ${CliHelper_1.default.get().getApiMethodsDescription()}`,
                type: 'list',
                default: params && 'GET',
                choices: CliHelper_1.default.get().getApiMethodsAsOptions(),
                filter: (method) => !this.findParamValue(params, K.method)
                    ? ValidationsHandler_1.userCancelOperation(!method, true) || method
                    : method.trim(),
                validate: (method) => method && Constants_1.default.API_METHODS.includes(method)
                    ? true
                    : `Please enter a valid method, one of: ${CliHelper_1.default.get().getApiMethodsDescription()}`
            },
            {
                name: K.data,
                char: 'd',
                env: 'CAPROVER_API_DATA',
                message: 'API data JSON string' +
                    (params
                        ? ''
                        : ' (or also JSON object from config file), for "GET" method they are interpreted as querystring values to be appended to the path'),
                type: 'input',
                filter: data => {
                    if (data && typeof data === 'string') {
                        try {
                            return JSON.parse(data);
                        }
                        catch (_a) {
                            // do nothing
                        }
                    }
                    return data;
                },
                validate: data => {
                    if (data && typeof data === 'string') {
                        try {
                            JSON.parse(data);
                        }
                        catch (e) {
                            return e;
                        }
                    }
                    return true;
                }
            },
            {
                name: K.out,
                char: 'o',
                env: 'CAPROVER_API_OUTPUT',
                message: 'where to log API response output: if "true" log to console, if "false" suppress output, otherwise log to specified file (overwrite already existing)',
                type: 'input',
                default: 'true',
                filter: (out) => {
                    if (!out) {
                        return 'false';
                    }
                    out = out.trim() || 'false';
                    if (out === 'true' || out === 'false' || path_1.isAbsolute(out)) {
                        return out;
                    }
                    return path_1.join(process.cwd(), out);
                }
            },
            {
                name: 'confirmedToCall',
                type: 'confirm',
                message: 'are you sure you want to procede?',
                default: true,
                hide: true,
                when: () => this.paramFrom(params, K.name) === Command_1.ParamType.Question ||
                    this.paramFrom(params, K.path) === Command_1.ParamType.Question ||
                    this.paramFrom(params, K.data) === Command_1.ParamType.Question,
                preProcessParam: (param) => param && ValidationsHandler_1.userCancelOperation(!param.value)
            }
        ];
    }
    preAction(cmdLineoptions) {
        return __awaiter(this, void 0, void 0, function* () {
            StdOutUtil_1.default.printMessage('Call generic CapRover API [Experimental Feature]...\n');
            return Promise.resolve(cmdLineoptions);
        });
    }
    action(params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield CliApiManager_1.default.get(this.machine).callApi(this.findParamValue(params, K.path).value, this.findParamValue(params, K.method).value, this.paramValue(params, K.data));
                StdOutUtil_1.default.printGreenMessage(`API call completed successfully!\n`);
                const out = this.paramValue(params, K.out);
                const data = JSON.stringify(resp, null, 2);
                if (out === 'true') {
                    StdOutUtil_1.default.printMessage(data + '\n');
                }
                else if (out !== 'false') {
                    try {
                        fs_1.writeFileSync(out, data);
                    }
                    catch (e) {
                        StdOutUtil_1.default.printWarning(`Error writing API response to file: "${out}".\n`);
                    }
                }
            }
            catch (error) {
                StdOutUtil_1.default.printError(`\nSomething bad happened calling API ${StdOutUtil_1.default.getColoredMachineUrl(this.paramValue(params, K.path))} at ${this.machine.name
                    ? StdOutUtil_1.default.getColoredMachineName(this.machine.name)
                    : StdOutUtil_1.default.getColoredMachineUrl(this.machine.baseUrl)}.`);
                StdOutUtil_1.default.errorHandler(error);
            }
        });
    }
}
exports.default = Api;
//# sourceMappingURL=api.js.map