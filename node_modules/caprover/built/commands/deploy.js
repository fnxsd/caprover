#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Constants_1 = require("../utils/Constants");
const Utils_1 = require("../utils/Utils");
const StdOutUtil_1 = require("../utils/StdOutUtil");
const StorageHelper_1 = require("../utils/StorageHelper");
const CliHelper_1 = require("../utils/CliHelper");
const DeployHelper_1 = require("../utils/DeployHelper");
const CliApiManager_1 = require("../api/CliApiManager");
const ValidationsHandler_1 = require("../utils/ValidationsHandler");
const Command_1 = require("./Command");
const K = Utils_1.default.extendCommonKeys({
    default: 'default',
    branch: 'branch',
    tar: 'tarFile',
    appToken: 'appToken',
    img: 'imageName'
});
class Deploy extends Command_1.default {
    constructor() {
        super(...arguments);
        this.command = 'deploy';
        this.usage = '[options]\n' +
            '       deploy -d\n' +
            '       deploy -c file\n' +
            '       deploy [-c file] [-n name] [-a app] [-b branch | -t tarFile | -i image]\n' +
            '       deploy [-c file] -u url [-p password] [-n name] [-a app] [-b branch | -t tarFile | -i image]\n' +
            '  Use --caproverName to use an already logged in CapRover machine\n' +
            '  Use --caproverUrl and --caproverPassword to login on the fly to a CapRover machine, if also --caproverName is present, login credetials are stored locally\n' +
            '  Use one among --branch, --tarFile, --imageName';
        this.description = "Deploy your app to a specific CapRover machine. You'll be prompted for missing parameters.";
        this.machines = CliHelper_1.default.get().getMachinesAsOptions();
        this.apps = [];
        this.options = (params) => [
            {
                name: K.default,
                char: 'd',
                type: 'confirm',
                message: 'use previously entered values for the current directory, no others options are considered',
                when: false
            },
            this.getDefaultConfigFileOption(() => this.validateDeploySource(params)),
            {
                name: K.url,
                char: 'u',
                env: 'CAPROVER_URL',
                aliases: [{ name: 'host', char: 'h' }],
                type: 'input',
                message: `CapRover machine URL address, it is "[http[s]://][${Constants_1.default.ADMIN_DOMAIN}.]your-captain-root.domain"`,
                when: false,
                filter: (url) => Utils_1.default.cleanAdminDomainUrl(url) || url,
                validate: (url) => ValidationsHandler_1.getErrorForDomain(url, true)
            },
            {
                name: K.pwd,
                char: 'p',
                env: 'CAPROVER_PASSWORD',
                aliases: [{ name: 'pass' }],
                type: 'password',
                message: 'CapRover machine password',
                when: !!this.findParamValue(params, K.url) &&
                    !this.findParamValue(params, K.appToken),
                validate: (password) => ValidationsHandler_1.getErrorForPassword(password)
            },
            {
                name: K.name,
                char: 'n',
                env: 'CAPROVER_NAME',
                message: params
                    ? 'select the CapRover machine name you want to deploy to'
                    : 'CapRover machine name, to load/store credentials',
                type: 'list',
                choices: this.machines,
                when: !this.findParamValue(params, K.url),
                filter: (name) => !this.findParamValue(params, K.name)
                    ? ValidationsHandler_1.userCancelOperation(!name, true) || name
                    : name.trim(),
                validate: !this.findParamValue(params, K.url)
                    ? (name) => ValidationsHandler_1.getErrorForMachineName(name, true)
                    : undefined
            },
            CliHelper_1.default.get().getEnsureAuthenticationOption(this.paramValue(params, K.appToken) || '', () => this.paramValue(params, K.url), () => this.paramValue(params, K.pwd), () => this.paramValue(params, K.name), (machine) => __awaiter(this, void 0, void 0, function* () {
                this.machine = machine;
                try {
                    if (machine.appToken) {
                        this.apps = [];
                        return;
                    }
                    this.apps =
                        (yield CliApiManager_1.default.get(machine).getAllApps())
                            .appDefinitions || [];
                }
                catch (e) {
                    StdOutUtil_1.default.printError(`\nSomething bad happened during deployment to ${StdOutUtil_1.default.getColoredMachineUrl(machine.baseUrl)}.\n${e.message || e}`, true);
                }
            })),
            {
                name: K.app,
                char: 'a',
                env: 'CAPROVER_APP',
                aliases: [{ name: 'appName' }],
                message: params
                    ? 'select the app name you want to deploy to'
                    : 'app name to deploy to',
                type: 'list',
                choices: () => CliHelper_1.default.get().getAppsAsOptions(this.apps),
                filter: (app) => !this.findParamValue(params, K.app)
                    ? ValidationsHandler_1.userCancelOperation(!app, true) || app
                    : app.trim(),
                validate: (app) => this.findParamValue(params, K.appToken)
                    ? true
                    : ValidationsHandler_1.getErrorForAppName(this.apps, app)
            },
            {
                name: K.branch,
                char: 'b',
                env: 'CAPROVER_BRANCH',
                message: 'git branch name to be deployed' +
                    (!params
                        ? ', current directory must be git root directory'
                        : ''),
                type: 'input',
                default: params && (process.env.CAPROVER_DEFAULT_BRANCH || 'master'),
                when: !this.findParamValue(params, K.tar) &&
                    !this.findParamValue(params, K.img),
                validate: (branch) => ValidationsHandler_1.getErrorForBranchName(branch)
            },
            {
                name: K.tar,
                char: 't',
                env: 'CAPROVER_TAR_FILE',
                message: 'tar file to be uploaded, must contain captain-definition file',
                type: 'input',
                when: false
            },
            {
                name: K.img,
                char: 'i',
                env: 'CAPROVER_IMAGE_NAME',
                message: 'image name to be deployed, it should either exist on server, or it has to be public, or on a private repository that CapRover has access to',
                type: 'input',
                when: false
            },
            {
                name: K.appToken,
                char: 't',
                env: 'CAPROVER_APP_TOKEN',
                message: 'app Token',
                type: 'input',
                when: false
            },
            {
                name: 'confirmedToDeploy',
                type: 'confirm',
                message: () => (this.findParamValue(params, K.branch)
                    ? 'note that uncommitted and gitignored files (if any) will not be pushed to server! A'
                    : 'a') + 're you sure you want to deploy?',
                default: true,
                hide: true,
                when: () => this.paramFrom(params, K.name) === Command_1.ParamType.Question ||
                    this.paramFrom(params, K.app) === Command_1.ParamType.Question ||
                    this.paramFrom(params, K.branch) === Command_1.ParamType.Question,
                preProcessParam: (param) => param && ValidationsHandler_1.userCancelOperation(!param.value)
            }
        ];
    }
    preAction(cmdLineoptions) {
        return __awaiter(this, void 0, void 0, function* () {
            StdOutUtil_1.default.printMessage('Preparing deployment to CapRover...\n');
            const possibleApp = StorageHelper_1.default.get()
                .getDeployedDirectories()
                .find((dir) => dir.cwd === process.cwd());
            if (cmdLineoptions[K.default]) {
                if (possibleApp && possibleApp.machineNameToDeploy) {
                    if (!StorageHelper_1.default.get().findMachine(possibleApp.machineNameToDeploy)) {
                        StdOutUtil_1.default.printError(`You have to first login to ${StdOutUtil_1.default.getColoredMachineName(possibleApp.machineNameToDeploy)} CapRover machine to use previously saved deploy options from this directory with --default.\n`, true);
                    }
                    this.options = (params) => [
                        CliHelper_1.default.get().getEnsureAuthenticationOption('', undefined, undefined, possibleApp.machineNameToDeploy, (machine) => __awaiter(this, void 0, void 0, function* () {
                            this.machine = machine;
                            try {
                                this.apps =
                                    (yield CliApiManager_1.default.get(machine).getAllApps()).appDefinitions || [];
                            }
                            catch (e) {
                                StdOutUtil_1.default.printError(`\nSomething bad happened during deployment to ${StdOutUtil_1.default.getColoredMachineName(machine.name)}.\n${e.message || e}`, true);
                            }
                            const appErr = ValidationsHandler_1.getErrorForAppName(this.apps, possibleApp.appName);
                            if (appErr !== true) {
                                StdOutUtil_1.default.printError(`\n${appErr || 'Error!'}\n`, true);
                            }
                            if (params) {
                                params[K.app] = {
                                    value: possibleApp.appName,
                                    from: Command_1.ParamType.Default
                                };
                                if (possibleApp.deploySource.branchToPush) {
                                    params[K.branch] = {
                                        value: possibleApp.deploySource
                                            .branchToPush,
                                        from: Command_1.ParamType.Default
                                    };
                                }
                                else if (possibleApp.deploySource.tarFilePath) {
                                    params[K.tar] = {
                                        value: possibleApp.deploySource
                                            .tarFilePath,
                                        from: Command_1.ParamType.Default
                                    };
                                }
                                else {
                                    params[K.img] = {
                                        value: possibleApp.deploySource.imageName,
                                        from: Command_1.ParamType.Default
                                    };
                                }
                                this.validateDeploySource(params);
                            }
                        }))
                    ];
                    return Promise.resolve({});
                }
                else {
                    StdOutUtil_1.default.printError(`Can't find previously saved deploy options from this directory, can't use --default.\n`);
                    StdOutUtil_1.default.printMessage('Falling back to asking questions...\n');
                }
            }
            else if (possibleApp &&
                possibleApp.machineNameToDeploy &&
                StorageHelper_1.default.get().findMachine(possibleApp.machineNameToDeploy)) {
                StdOutUtil_1.default.printTip('**** Protip ****');
                StdOutUtil_1.default.printMessage(`You seem to have deployed ${StdOutUtil_1.default.getColoredMachineName(possibleApp.appName)} from this directory in the past, use --default flag to avoid having to re-enter the information.\n`);
            }
            return Promise.resolve(cmdLineoptions);
        });
    }
    validateDeploySource(params) {
        if ((this.findParamValue(params, K.branch) ? 1 : 0) +
            (this.findParamValue(params, K.tar) ? 1 : 0) +
            (this.findParamValue(params, K.img) ? 1 : 0) >
            1) {
            StdOutUtil_1.default.printError('Only one of branch, tarFile or imageName can be present in deploy.\n', true);
        }
        if (!this.findParamValue(params, K.tar) &&
            !this.findParamValue(params, K.img)) {
            ValidationsHandler_1.validateIsGitRepository();
            ValidationsHandler_1.validateDefinitionFile();
        }
    }
    action(params) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.deploy({
                captainMachine: this.machine,
                deploySource: {
                    branchToPush: this.paramValue(params, K.branch),
                    tarFilePath: this.paramValue(params, K.tar),
                    imageName: this.paramValue(params, K.img)
                },
                appName: this.paramValue(params, K.app)
            }, this.apps.find(app => app.appName === this.paramValue(params, K.app)));
        });
    }
    deploy(deployParams, app) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (yield new DeployHelper_1.default(app && app.hasDefaultSubDomainSsl).startDeploy(deployParams)) {
                    StorageHelper_1.default.get().saveDeployedDirectory({
                        appName: deployParams.appName || '',
                        cwd: process.cwd(),
                        deploySource: deployParams.deploySource,
                        machineNameToDeploy: deployParams.captainMachine
                            ? deployParams.captainMachine.name
                            : ''
                    });
                }
            }
            catch (error) {
                const errorMessage = error.message ? error.message : error;
                StdOutUtil_1.default.printError(`\nSomething bad happened: cannot deploy ${StdOutUtil_1.default.getColoredAppName(deployParams.appName || '')} at ${StdOutUtil_1.default.getColoredMachineName(deployParams.captainMachine
                    ? deployParams.captainMachine.name ||
                        deployParams.captainMachine.baseUrl
                    : '')}.\n${errorMessage}\n`, true);
            }
        });
    }
}
exports.default = Deploy;
//# sourceMappingURL=deploy.js.map