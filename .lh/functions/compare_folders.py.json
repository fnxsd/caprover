{
    "sourceFile": "functions/compare_folders.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 56,
            "patches": [
                {
                    "date": 1701773634027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1701773641449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+    \"\"\"\n+     _summary_\n+    \"\"\"\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773646772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,6 @@\n #!/usr/bin/env python3\n # -*- coding: utf-8 -*-\n \n-    \"\"\"\n-     _summary_\n-    \"\"\"\n-#!/usr/bin/env python3\n\\ No newline at end of file\n+\"\"\"\n+ _summary_\n+\"\"\"\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773653384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facil\n+\"\"\"\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773658513,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and \n+\"\"\"\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773666624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,18 +1,6 @@\n #!/usr/bin/env python3\n # -*- coding: utf-8 -*-\n \n \"\"\"\n-Functions to facilitate the comparison of folders and \n-\"\"\"\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facil\n-\"\"\"\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n- _summary_\n+Functions to facilitate the comparison of folders and files, including \n \"\"\"\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773674088,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,6 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773687623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,8 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+\n+\n"
                },
                {
                    "date": 1701773696214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,10 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+\n+\n+from dataclasses import dataclass\n+\n"
                },
                {
                    "date": 1701773709624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,12 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+\n+\n+from dataclasses import dataclass\n+\n+@dataclass\n+class F\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773715802,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,35 +8,6 @@\n \n from dataclasses import dataclass\n \n @dataclass\n-class F\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-\n-\n-from dataclasses import dataclass\n-\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-\n-\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including \n-\"\"\"\n\\ No newline at end of file\n+class Folder:\n+    \n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773732724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,5 +9,41 @@\n from dataclasses import dataclass\n \n @dataclass\n class Folder:\n-    \n\\ No newline at end of file\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+    path: str\n+    name: str\n+    files: list\n+    folders: list\n+\n+    def __init__(self, path: str, name: str, files: list, folders: list):\n+        self.path = path\n+        self.name = name\n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773745049,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,48 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional\n+from dataclasses import dataclass\n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+    path: str\n+    name: str\n+    files: list\n+    folders: list\n+\n+    def __init__(self, path: str, name: str, files: list, folders: list):\n+        self.path = path\n+        self.name = name\n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773756460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,13 +3,13 @@\n \n \"\"\"\n Functions to facilitate the comparison of folders and files, including their contents.\n \"\"\"\n-from typing import Optional\n+from typing import Optional,Sequence\n from dataclasses import dataclass\n \n @dataclass\n-class Folder:\n+class Folder[Sequence]:\n     \"\"\"\n     Dataclass for a folder.\n     \"\"\"\n     path: str\n@@ -44,54 +44,5 @@\n     def __gt__(self, other):\n         return self.name > other.name\n \n     def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-\n-\n-from dataclasses import dataclass\n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-    path: str\n-    name: str\n-    files: list\n-    folders: list\n-\n-    def __init__(self, path: str, name: str, files: list, folders: list):\n-        self.path = path\n-        self.name = name\n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n         return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773761850,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n from typing import Optional,Sequence\n from dataclasses import dataclass\n \n @dataclass\n-class Folder[Sequence]:\n+class Folder:\n     \"\"\"\n     Dataclass for a folder.\n     \"\"\"\n     path: str\n"
                },
                {
                    "date": 1701773899042,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     name: str\n     files: list\n     folders: list\n \n-    def __init__(self, path: str, name: str, files: list, folders: list):\n+    def __init__(self, path: str, name: [str], files: list, folders: list):\n         self.path = path\n         self.name = name\n         self.files = files\n         self.folders = folders\n"
                },
                {
                    "date": 1701773904333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     name: str\n     files: list\n     folders: list\n \n-    def __init__(self, path: str, name: [str], files: list, folders: list):\n+    def __init__(self, path: str, name: Optional[str], files: [list], folders: [list]):\n         self.path = path\n         self.name = name\n         self.files = files\n         self.folders = folders\n"
                },
                {
                    "date": 1701773910487,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     name: str\n     files: list\n     folders: list\n \n-    def __init__(self, path: str, name: Optional[str], files: [list], folders: [list]):\n+    def __init__(self, path: str, name: Optional[str], files: Optional[list], folders: Optional[list]=None):\n         self.path = path\n         self.name = name\n         self.files = files\n         self.folders = folders\n"
                },
                {
                    "date": 1701773916173,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n     name: str\n     files: list\n     folders: list\n \n-    def __init__(self, path: str, name: Optional[str], files: Optional[list], folders: Optional[list]=None):\n+    def __init__(self, path: str, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         self.path = path\n         self.name = name\n         self.files = files\n         self.folders = folders\n"
                },
                {
                    "date": 1701773924782,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,11 +16,11 @@\n     name: str\n     files: list\n     folders: list\n \n-    def __init__(self, path: str, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+    def __init__(self, path: str,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         self.path = path\n-        self.name = name\n+        self.name = name or \n         self.files = files\n         self.folders = folders\n \n     def __str__(self):\n"
                },
                {
                    "date": 1701773932878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n \"\"\"\n Functions to facilitate the comparison of folders and files, including their contents.\n \"\"\"\n from typing import Optional,Sequence\n+from pathlib import Path\n from dataclasses import dataclass\n \n @dataclass\n class Folder:\n@@ -18,9 +19,9 @@\n     folders: list\n \n     def __init__(self, path: str,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         self.path = path\n-        self.name = name or \n+        self.name = name \n         self.files = files\n         self.folders = folders\n \n     def __str__(self):\n"
                },
                {
                    "date": 1701773941376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,9 +6,9 @@\n \"\"\"\n from typing import Optional,Sequence\n from pathlib import Path\n from dataclasses import dataclass\n-\n+from _typeshed import StrOrBytesPath\n @dataclass\n class Folder:\n     \"\"\"\n     Dataclass for a folder.\n"
                },
                {
                    "date": 1701773955198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n \n \"\"\"\n Functions to facilitate the comparison of folders and files, including their contents.\n \"\"\"\n-from typing import Optional,Sequence\n+from typing import Optional,Sequence,Any,AnyStr\n from pathlib import Path\n from dataclasses import dataclass\n from _typeshed import StrOrBytesPath\n @dataclass\n"
                },
                {
                    "date": 1701773962183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,57 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,Any,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from _typeshed import StrOrBytesPath\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+    path: str\n+    name: str\n+    files: list\n+    folders: list\n+\n+    def __init__(self, path: str,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        self.path = path\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773968205,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n \n \"\"\"\n Functions to facilitate the comparison of folders and files, including their contents.\n \"\"\"\n-from typing import Optional,Sequence,Any,AnyStr\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n from pathlib import Path\n from dataclasses import dataclass\n from _typeshed import StrOrBytesPath\n from os import PathLike\n@@ -53,54 +53,5 @@\n     def __gt__(self, other):\n         return self.name > other.name\n \n     def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,Any,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from _typeshed import StrOrBytesPath\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-    path: str\n-    name: str\n-    files: list\n-    folders: list\n-\n-    def __init__(self, path: str,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        self.path = path\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n         return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773978064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,56 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+    path: str\n+    name: str\n+    files: list\n+    folders: list\n+\n+    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        self.path = path\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701773991462,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,65 +25,20 @@\n     files: list\n     folders: list\n \n     def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        self.path = path\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n+        \"\"\"\n+        __init__ _summary_\n \n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from _typeshed import StrOrBytesPath\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-    path: str\n-    name: str\n-    files: list\n-    folders: list\n-\n-    def __init__(self, path: str,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        :param path: _description_\n+        :type path: StrOrBytesPath\n+        :param name: _description_, defaults to None\n+        :type name: Optional[str], optional\n+        :param files: _description_, defaults to None\n+        :type files: Optional[list], optional\n+        :param folders: _description_, defaults to None\n+        :type folders: Optional[list], optional\n+        \"\"\"\n         self.path = path\n         self.name = name \n         self.files = files\n         self.folders = folders\n"
                },
                {
                    "date": 1701773997206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,11 +26,11 @@\n     folders: list\n \n     def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         \"\"\"\n-        __init__ _summary_\n+        __init__ method for Folder class.\n \n-        :param path: _description_\n+        :param path: \n         :type path: StrOrBytesPath\n         :param name: _description_, defaults to None\n         :type name: Optional[str], optional\n         :param files: _description_, defaults to None\n"
                },
                {
                    "date": 1701774003619,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n     def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         \"\"\"\n         __init__ method for Folder class.\n \n-        :param path: \n+        :param path: Path to the folder, defaults to None\n         :type path: StrOrBytesPath\n         :param name: _description_, defaults to None\n         :type name: Optional[str], optional\n         :param files: _description_, defaults to None\n"
                },
                {
                    "date": 1701774009803,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n     def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         \"\"\"\n         __init__ method for Folder class.\n \n-        :param path: Path to the folder, defaults to None\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n         :type path: StrOrBytesPath\n         :param name: _description_, defaults to None\n         :type name: Optional[str], optional\n         :param files: _description_, defaults to None\n"
                },
                {
                    "date": 1701774022358,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,68 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+    path: str\n+    name: str\n+    files: list\n+    folders: list\n+\n+    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :type path: StrOrBytesPath\n+        :param name: Name override, defaults to None\n+        :type name: Optional[str], optional\n+        :param files: _description_, defaults to None\n+        :type files: Optional[list], optional\n+        :param folders: _description_, defaults to None\n+        :type folders: Optional[list], optional\n+        \"\"\"\n+        self.path = path\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774028637,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n         :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n         :type path: StrOrBytesPath\n         :param name: Name override, defaults to None\n         :type name: Optional[str], optional\n-        :param files: _description_, defaults to None\n+        :param files: File list, defaults to None\n         :type files: Optional[list], optional\n         :param folders: _description_, defaults to None\n         :type folders: Optional[list], optional\n         \"\"\"\n@@ -64,73 +64,5 @@\n     def __gt__(self, other):\n         return self.name > other.name\n \n     def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-    path: str\n-    name: str\n-    files: list\n-    folders: list\n-\n-    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :type path: StrOrBytesPath\n-        :param name: _description_, defaults to None\n-        :type name: Optional[str], optional\n-        :param files: _description_, defaults to None\n-        :type files: Optional[list], optional\n-        :param folders: _description_, defaults to None\n-        :type folders: Optional[list], optional\n-        \"\"\"\n-        self.path = path\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n         return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774044158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,68 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+    path: str\n+    name: str\n+    files: list\n+    folders: list\n+\n+    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :type path: StrOrBytesPath\n+        :param name: Name override, defaults to None\n+        :type name: Optional[str], optional\n+        :param files: File list that will be reported, defaults to None\n+        :type files: Optional[list], optional\n+        :param folders: _description_, defaults to None\n+        :type folders: Optional[list], optional\n+        \"\"\"\n+        self.path = path\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774051374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,68 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+    path: str\n+    name: str\n+    files: list\n+    folders: list\n+\n+    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :type path: StrOrBytesPath\n+        :param name: Name override, defaults to None\n+        :type name: Optional[str], optional\n+        :param files: File list that will be reported, defaults to None\n+        :type files: Optional[list], optional\n+        :param folders: Folde list that will be reported, defaults to None\n+        :type folders: Optional[list], optional\n+        \"\"\"\n+        self.path = path\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774057152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+    path: str\n+    name: str\n+    files: list\n+    folders: list\n+\n+    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        self.path = path\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774062987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n     name: str\n     files: list\n     folders: list\n \n-    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+    def __init__(self, path: [StrOrBytesPath],*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         \"\"\"\n         __init__ method for Folder class.\n \n         :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n@@ -60,209 +60,5 @@\n     def __gt__(self, other):\n         return self.name > other.name\n \n     def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-    path: str\n-    name: str\n-    files: list\n-    folders: list\n-\n-    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :type path: StrOrBytesPath\n-        :param name: Name override, defaults to None\n-        :type name: Optional[str], optional\n-        :param files: File list that will be reported, defaults to None\n-        :type files: Optional[list], optional\n-        :param folders: Folde list that will be reported, defaults to None\n-        :type folders: Optional[list], optional\n-        \"\"\"\n-        self.path = path\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-    path: str\n-    name: str\n-    files: list\n-    folders: list\n-\n-    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :type path: StrOrBytesPath\n-        :param name: Name override, defaults to None\n-        :type name: Optional[str], optional\n-        :param files: File list that will be reported, defaults to None\n-        :type files: Optional[list], optional\n-        :param folders: _description_, defaults to None\n-        :type folders: Optional[list], optional\n-        \"\"\"\n-        self.path = path\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-    path: str\n-    name: str\n-    files: list\n-    folders: list\n-\n-    def __init__(self, path: StrOrBytesPath,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :type path: StrOrBytesPath\n-        :param name: Name override, defaults to None\n-        :type name: Optional[str], optional\n-        :param files: File list, defaults to None\n-        :type files: Optional[list], optional\n-        :param folders: _description_, defaults to None\n-        :type folders: Optional[list], optional\n-        \"\"\"\n-        self.path = path\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n         return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774068175,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n     name: str\n     files: list\n     folders: list\n \n-    def __init__(self, path: [StrOrBytesPath],*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         \"\"\"\n         __init__ method for Folder class.\n \n         :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n"
                },
                {
                    "date": 1701774075368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,13 +19,10 @@\n class Folder:\n     \"\"\"\n     Dataclass for a folder.\n     \"\"\"\n-    path: str\n-    name: str\n-    files: list\n-    folders: list\n \n+\n     def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         \"\"\"\n         __init__ method for Folder class.\n \n"
                },
                {
                    "date": 1701774083320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,61 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        self._path = Pathpath\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774097926,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,61 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        self._path = Path(path) if path else Path.cwd()\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774127081,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,61 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        self._path = Path(str(path)) if path is not None else Path.cwd()\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774136060,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,61 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        self._path = Path(path if isinstance()) if path is not None else Path.cwd()\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774143457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,61 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        self._path = Path(path if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774151011,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n         :param name: Name override, defaults to None\n         :param files: File list that will be reported, defaults to None\n         :param folders: Folde list that will be reported, defaults to None\n         \"\"\"\n-        self._path = Path(path if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n+        self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n         self.name = name \n         self.files = files\n         self.folders = folders\n \n@@ -57,310 +57,5 @@\n     def __gt__(self, other):\n         return self.name > other.name\n \n     def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-\n-\n-    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :param name: Name override, defaults to None\n-        :param files: File list that will be reported, defaults to None\n-        :param folders: Folde list that will be reported, defaults to None\n-        \"\"\"\n-        self._path = Path(path if isinstance()) if path is not None else Path.cwd()\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-\n-\n-    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :param name: Name override, defaults to None\n-        :param files: File list that will be reported, defaults to None\n-        :param folders: Folde list that will be reported, defaults to None\n-        \"\"\"\n-        self._path = Path(str(path)) if path is not None else Path.cwd()\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-\n-\n-    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :param name: Name override, defaults to None\n-        :param files: File list that will be reported, defaults to None\n-        :param folders: Folde list that will be reported, defaults to None\n-        \"\"\"\n-        self._path = Path(path) if path else Path.cwd()\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-\n-\n-    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :param name: Name override, defaults to None\n-        :param files: File list that will be reported, defaults to None\n-        :param folders: Folde list that will be reported, defaults to None\n-        \"\"\"\n-        self._path = Pathpath\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-\n-\n-    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :param name: Name override, defaults to None\n-        :param files: File list that will be reported, defaults to None\n-        :param folders: Folde list that will be reported, defaults to None\n-        \"\"\"\n-        self.path = path\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n         return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774165812,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,63 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        if path:\n+            if is\n+        self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774172770,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,64 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        if path:\n+            if isinstance(path, Path):\n+                \n+        self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774178663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,10 @@\n         :param folders: Folde list that will be reported, defaults to None\n         \"\"\"\n         if path:\n             if isinstance(path, Path):\n+                self._path = path\n+            else:\n                 \n         self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n         self.name = name \n         self.files = files\n@@ -60,129 +62,5 @@\n     def __gt__(self, other):\n         return self.name > other.name\n \n     def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-\n-\n-    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :param name: Name override, defaults to None\n-        :param files: File list that will be reported, defaults to None\n-        :param folders: Folde list that will be reported, defaults to None\n-        \"\"\"\n-        if path:\n-            if is\n-        self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-\n-\n-    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :param name: Name override, defaults to None\n-        :param files: File list that will be reported, defaults to None\n-        :param folders: Folde list that will be reported, defaults to None\n-        \"\"\"\n-        self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n         return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774185677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n         if path:\n             if isinstance(path, Path):\n                 self._path = path\n             else:\n-                \n+                self._path = Path(path if isinstance(path, str) else path.decode())\n         self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n         self.name = name \n         self.files = files\n         self.folders = folders\n"
                },
                {
                    "date": 1701774206986,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,66 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        if path:\n+            if isinstance(path, Path):\n+                self._path = path\n+            else:\n+                self._path = Path(str(path))\n+        self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n+        self.name = name \n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774221138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,66 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        if path:\n+            if isinstance(path, Path):\n+                self._path = path\n+            else:\n+                self._path = Path(str(path))\n+        \n+        self.name = name or self._path.name\n+        self.files = files\n+        self.folders = folders\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774230010,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,9 +37,9 @@\n             else:\n                 self._path = Path(str(path))\n         \n         self.name = name or self._path.name\n-        self.files = files\n+        self._\n         self.folders = folders\n \n     def __str__(self):\n         return f\"{self.name} ({self.path})\"\n@@ -62,137 +62,5 @@\n     def __gt__(self, other):\n         return self.name > other.name\n \n     def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-\n-\n-    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :param name: Name override, defaults to None\n-        :param files: File list that will be reported, defaults to None\n-        :param folders: Folde list that will be reported, defaults to None\n-        \"\"\"\n-        if path:\n-            if isinstance(path, Path):\n-                self._path = path\n-            else:\n-                self._path = Path(str(path))\n-        self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n-        return self.name >= other.name\n-#!/usr/bin/env python3\n-# -*- coding: utf-8 -*-\n-\n-\"\"\"\n-Functions to facilitate the comparison of folders and files, including their contents.\n-\"\"\"\n-from typing import Optional,Sequence,TypeAlias,AnyStr\n-from pathlib import Path\n-from dataclasses import dataclass\n-from os import PathLike\n-\n-\n-StrPath: TypeAlias = str | PathLike[str]  # stable\n-BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n-GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n-StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n-\n-@dataclass\n-class Folder:\n-    \"\"\"\n-    Dataclass for a folder.\n-    \"\"\"\n-\n-\n-    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n-        \"\"\"\n-        __init__ method for Folder class.\n-\n-        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n-        :param name: Name override, defaults to None\n-        :param files: File list that will be reported, defaults to None\n-        :param folders: Folde list that will be reported, defaults to None\n-        \"\"\"\n-        if path:\n-            if isinstance(path, Path):\n-                self._path = path\n-            else:\n-                self._path = Path(path if isinstance(path, str) else path.decode())\n-        self._path = Path(path.decode() if isinstance(path, bytes) else path) if path is not None else Path.cwd()\n-        self.name = name \n-        self.files = files\n-        self.folders = folders\n-\n-    def __str__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __repr__(self):\n-        return f\"{self.name} ({self.path})\"\n-\n-    def __eq__(self, other):\n-        return self.path == other.path\n-\n-    def __hash__(self):\n-        return hash(self.path)\n-\n-    def __lt__(self, other):\n-        return self.name < other.name\n-\n-    def __le__(self, other):\n-        return self.name <= other.name\n-\n-    def __gt__(self, other):\n-        return self.name > other.name\n-\n-    def __ge__(self, other):\n         return self.name >= other.name\n\\ No newline at end of file\n"
                },
                {
                    "date": 1701774235455,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,10 +36,10 @@\n                 self._path = path\n             else:\n                 self._path = Path(str(path))\n         \n-        self.name = name or self._path.name\n-        self._\n+        self._name = name or self._path.name\n+        self._f\n         self.folders = folders\n \n     def __str__(self):\n         return f\"{self.name} ({self.path})\"\n"
                },
                {
                    "date": 1701774247714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,8 +20,9 @@\n     \"\"\"\n     Dataclass for a folder.\n     \"\"\"\n \n+    \n \n     def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         \"\"\"\n         __init__ method for Folder class.\n@@ -37,10 +38,10 @@\n             else:\n                 self._path = Path(str(path))\n         \n         self._name = name or self._path.name\n-        self._f\n-        self.folders = folders\n+        self._files = files or []\n+        self._folders = folders or []\n \n     def __str__(self):\n         return f\"{self.name} ({self.path})\"\n \n"
                },
                {
                    "date": 1701774255691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,15 @@\n     \"\"\"\n     Dataclass for a folder.\n     \"\"\"\n \n+    @property\n+    def name(self) -> Any:\n+        return self.__name\n     \n+    @name.setter\n+    def name(self, value) -> None:\n+        self.__name = value\n \n     def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         \"\"\"\n         __init__ method for Folder class.\n"
                },
                {
                    "date": 1701774265068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n     \"\"\"\n \n     @property\n     def name(self) -> Any:\n-        return self.__name\n+        return self._name\n     \n     @name.setter\n     def name(self, value) -> None:\n         self.__name = value\n"
                },
                {
                    "date": 1701774274714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,12 +23,8 @@\n \n     @property\n     def name(self) -> str:\n         return self._name\n-    \n-    @name.setter\n-    def name(self, value) -> None:\n-        self.__name = value\n \n     def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n         \"\"\"\n         __init__ method for Folder class.\n"
                },
                {
                    "date": 1701774301019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+#!/usr/bin/env python3\n+# -*- coding: utf-8 -*-\n+\n+\"\"\"\n+Functions to facilitate the comparison of folders and files, including their contents.\n+\"\"\"\n+from typing import Optional,Sequence,TypeAlias,AnyStr\n+from pathlib import Path\n+from dataclasses import dataclass\n+from os import PathLike\n+\n+\n+StrPath: TypeAlias = str | PathLike[str]  # stable\n+BytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\n+GenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\n+StrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  \n+\n+@dataclass\n+class Folder:\n+    \"\"\"\n+    Dataclass for a folder.\n+    \"\"\"\n+\n+    @property\n+    def name(self) -> str:\n+        return self._name\n+    @property\n+    def str_path(self) -> str:\n+        return str(self._path)\n+    @property\n+    def path(self) -> Path:\n+        return self._path\n+    def __init__(self, path: Optional[StrOrBytesPath]=None,*, name: Optional[str]=None, files: Optional[list]=None, folders: Optional[list]=None):\n+        \"\"\"\n+        __init__ method for Folder class.\n+\n+        :param path: Path to the folder, defaults to None. If None, the path will be set to the current working directory.\n+        :param name: Name override, defaults to None\n+        :param files: File list that will be reported, defaults to None\n+        :param folders: Folde list that will be reported, defaults to None\n+        \"\"\"\n+        if path:\n+            if isinstance(path, Path):\n+                self._path = path\n+            else:\n+                self._path = Path(str(path))\n+        \n+        self._name = name or self._path.name\n+        self._files = files or []\n+        self._folders = folders or []\n+\n+    def __str__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __repr__(self):\n+        return f\"{self.name} ({self.path})\"\n+\n+    def __eq__(self, other):\n+        return self.path == other.path\n+\n+    def __hash__(self):\n+        return hash(self.path)\n+\n+    def __lt__(self, other):\n+        return self.name < other.name\n+\n+    def __le__(self, other):\n+        return self.name <= other.name\n+\n+    def __gt__(self, other):\n+        return self.name > other.name\n+\n+    def __ge__(self, other):\n+        return self.name >= other.name\n\\ No newline at end of file\n"
                }
            ],
            "date": 1701773634027,
            "name": "Commit-0",
            "content": "#!/usr/bin/env python3\n"
        }
    ]
}